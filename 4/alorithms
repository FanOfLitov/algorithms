    Класс State - представление состояния автомата

    Класс NFA - недетерминированный конечный автомат

    Класс DFA - детерминированный конечный автомат

    Класс RegexInterpreter - интерпретатор регулярных выражений

    Класс KMP - реализация алгоритма Кнута-Морриса-Пратта

    Класс RegexTester - тестирование и сравнение алгоритмов


1. Алгоритм Томпсона для построения НКА

Идея алгоритма:
Преобразование регулярного выражения в НКА с использованием ε-переходов.

Шаги алгоритма:

    Преобразование в обратную польскую запись (RPN):
    python

def to_postfix(self, regex: str) -> str:

    Учитывает приоритет операторов: * и + > . (конкатенация) > |

    Добавляет явный оператор конкатенации .

Построение НКА из RPN:
python

def build_nfa_from_postfix(self, postfix: str) -> NFA:

Для каждого символа/оператора в RPN:

a. Символ (a):
text

start --a--> end

b. Конкатенация (A.B):
text

NFA1.start -> ... -> NFA1.end --ε--> NFA2.start -> ... -> NFA2.end

c. Объединение (A|B):
text

         --ε--> NFA1.start -> ... -> NFA1.end --ε-->
start <                                       > end
         --ε--> NFA2.start -> ... -> NFA2.end --ε-->

d. Звезда Клини (A*):
text

         --ε--> NFA.start -> ... -> NFA.end --ε--
start <                                      > end
         -------------------ε-------------------

e. Плюс (A+):
text

start --ε--> NFA.start -> ... -> NFA.end --ε--
                                       ↓
                                    --ε--> end

2. Алгоритм подмножеств для преобразования НКА в ДКА

Идея алгоритма:
Каждое состояние ДКА соответствует множеству состояний НКА.

Шаги алгоритма:

    Вычисление ε-замыкания:
    python

def epsilon_closure(self, states: Set[State]) -> Set[State]:

Все состояния, достижимые из данных по ε-переходам.

Построение таблицы переходов ДКА:
python

def nfa_to_dfa(self, nfa: NFA) -> DFA:

        Начальное состояние ДКА = ε-замыкание(start НКА)

        Для каждого состояния ДКА и каждого символа алфавита:

            Вычисляем все состояния НКА, достижимые по символу

            Вычисляем ε-замыкание этого множества

            Это становится новым состоянием ДКА

    Определение допускающих состояний ДКА:
    Состояние ДКА допускающее, если содержит хотя бы одно допускающее состояние НКА.

3. Алгоритм Кнута-Морриса-Пратта (KMP)

Идея алгоритма:
Предобработка шаблона для избежания возвратов в тексте.

Шаги алгоритма:

    Построение LPS (Longest Prefix Suffix) массива:
    python

@staticmethod
def build_lps(pattern: str) -> List[int]:

Для каждого префикса шаблона находит длину максимального собственного суффикса, который также является префиксом.

Пример для "ABAB":
text

Индекс: 0 1 2 3
Шаблон: A B A B
LPS:    0 0 1 2

Поиск с использованием LPS:
python

@staticmethod
def search(text: str, pattern: str) -> List[int]:

        При несовпадении символов используем LPS для определения следующей позиции в шаблоне

        Избегаем возвратов в тексте, сложность O(n + m)

4. Сравнение KMP и ДКА для поиска подстроки

Алгоритм поиска с ДКА:
python

@staticmethod
def search_with_dfa(text: str, pattern: str) -> List[int]:

    Строим ДКА для шаблона

    Для каждой позиции в тексте запускаем ДКА

    Если достигаем допускающего состояния - нашли совпадение

Сложность:

    KMP: O(n + m) время, O(m) память

    ДКА: O(n) время после построения, но построение ДКА может быть экспоненциальным

Подробное объяснение ключевых функций
1. Функция add_concat_operator
python

def add_concat_operator(self, regex: str) -> str:

Добавляет явный оператор конкатенации (.) в регулярное выражение.

Пример:
text

"a(b|c)*d" -> "a.(.(b|c)*).d"

Логика вставки:

    Между символом и символом: ab -> a.b

    Между символом и (: a( -> a.(

    Между ) и символом: )a -> ).a

    Между ) и (: )( -> ).(

    Между * и символом: *a -> *.a

    Между * и (: *( -> *.(

2. Функция to_postfix
python

def to_postfix(self, regex: str) -> str:

Преобразует инфиксное выражение в обратную польскую запись.

Алгоритм (алгоритм сортировочной станции):

    Инициализируем выходную строку и стек

    Для каждого токена:

        Если операнд -> добавить в выход

        Если ( -> положить в стек

        Если ) -> выталкивать из стека в выход до (

        Если оператор -> выталкивать операторы с большим или равным приоритетом

    Вытолкнуть оставшиеся операторы из стека

3. Функция epsilon_closure
python

def epsilon_closure(self, states: Set[State]) -> Set[State]:

Вычисляет все состояния, достижимые из данных по ε-переходам.

Алгоритм (обход в глубину):

    Начать с исходных состояний

    Для каждого состояния добавить все состояния по ε-переходам

    Рекурсивно обработать добавленные состояния

Пример работы программы
Пример 1: Простое регулярное выражение
text

Регулярное выражение: a(b|c)*d
Обратная польская запись: abc|*.d.

Построение НКА:

    a -> НКА для 'a'

    b -> НКА для 'b'

    c -> НКА для 'c'

    | -> объединение НКА для 'b' и 'c'

    * -> звезда Клини для (b|c)

    . -> конкатенация 'a' и (b|c)*

    d -> НКА для 'd'

    . -> конкатенация a(b|c)* и d

Пример 2: Сравнение KMP и ДКА
text

Шаблон: "abc"
Текст: "ababcabcab"

KMP:

    LPS для "abc": [0, 0, 0]

    Поиск находит совпадения на позициях 2 и 5

ДКА:

    Состояния: q0, q1, q2, q3 (q3 - допускающее)

    Переходы:

        q0 --a--> q1

        q1 --b--> q2

        q2 --c--> q3

    Поиск также находит совпадения на позициях 2 и 5

Особенности реализации

    Поддержка операторов:

        . - конкатенация (явный оператор)

        | - объединение

        * - ноль или более

        + - один или более

    Экранирование символов:
    python

if char == '\\':  # Обработка экранирования
    if i + 1 < len(regex):
        output.append(regex[i:i+2])
        i += 2

Оптимизации:

    Использование frozenset для хранения множеств состояний как ключей

    Мемоизация ε-замыканий

    Эффективные структуры данных (defaultdict, deque)

Тестирование и сравнение:

    Сравнение с Python re для проверки корректности

    Сравнение KMP и ДКА для поиска подстрок

    Генерация случайных тестовых строк