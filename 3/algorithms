Архитектура программы

Программа состоит из следующих основных компонентов:

    Класс DFA - представление детерминированного конечного автомата

    Функции чтения/записи - работа с CSV-файлами

    Алгоритмы минимизации - две реализации: таблицы различий и Хопкрофта

    Функция проверки эквивалентности - сравнение двух автоматов

    Основная функция - пользовательский интерфейс

Подробное объяснение алгоритмов
1. Алгоритм минимизации через таблицу различий

Идея алгоритма:
Разделить состояния на классы эквивалентности таким образом, что два состояния эквивалентны,
 если для любой входной строки они ведут к одинаковому результату (принятие/отклонение).

Шаги алгоритма:

    Начальное разбиение:
    python

partition = [dfa.accept_states.copy(), dfa.states - dfa.accept_states]

    Создаем два класса: допускающие и недопускающие состояния.

    Итерационное уточнение:
    Для каждого класса в разбиении:

        Группируем состояния по "сигнатурам" - на какие классы ведут переходы по каждому символу алфавита

        Если состояния внутри класса имеют разные сигнатуры, разбиваем класс на подклассы

    Критерий останова:
    Процесс повторяется до тех пор, пока разбиение не перестанет изменяться

    Построение нового ДКА:

        Каждый класс эквивалентности становится новым состоянием

        Переходы определяются на основе переходов представителя класса

        Начальное и допускающие состояния определяются по принадлежности исходных состояний

Пример работы:
Для ДКА с состояниями {q0, q1, q2, q3}, где q3 - допускающее:

    Начальное разбиение: [{q3}, {q0, q1, q2}]

    Проверяем класс {q0, q1, q2}:

        q0 по 'a' → q1 (класс 1), по 'b' → q2 (класс 1)

        q1 по 'a' → q2 (класс 1), по 'b' → q3 (класс 0)

        q2 по 'a' → q2 (класс 1), по 'b' → q2 (класс 1)
        Разные сигнатуры → разбиваем на {q0, q2} и {q1}

    Итоговое разбиение: [{q3}, {q0, q2}, {q1}]

2. Алгоритм Хопкрофта

Идея алгоритма:
Более эффективный алгоритм, использующий разделение блоков состояний.

Шаги алгоритма:

    Инициализация:
    python

P = [dfa.accept_states.copy(), dfa.states - dfa.accept_states]
W = deque(P)  # Очередь блоков для обработки

    Основной цикл:
    Пока очередь W не пуста:

        Извлекаем блок A

        Для каждого символа алфавита находим множество X состояний, которые переходят в A

        Для каждого блока Y в разбиении P:

            Если Y пересекается с X и имеет разность с X, разбиваем Y

            Обновляем очередь W

    Критерий останова:
    Когда очередь W становится пустой

Преимущества:

    Более эффективен для больших автоматов

    Меньше итераций в среднем случае

    Сложность O(n log n)

3. Алгоритм проверки эквивалентности

Идея алгоритма:
Два ДКА эквивалентны, если их начальные состояния неразличимы.

Шаги алгоритма (BFS-подход):

    Инициализация:
    python

start_pair = (dfa1.start_state, dfa2.start_state)
visited = {start_pair}
queue = deque([(start_pair, "")])

    Обход в ширину:
    Пока очередь не пуста:

        Извлекаем пару состояний и строку, которая к ним привела

        Проверяем, одинаково ли они допускают строку

        Для каждого символа алфавита добавляем новые пары состояний в очередь

    Критерии:

        Если найдена строка, которая принимается одним автоматом, но не другим → неэквивалентны

        Если все достижимые пары состояний ведут себя одинаково → эквивалентны

Объяснение ключевых функций
1. Класс DFA
python

class DFA:
    def __init__(self, states, alphabet, transitions, start_state, accept_states):

Хранит всю информацию о детерминированном конечном автомате:

    states - все состояния

    alphabet - входной алфавит

    transitions - функция переходов в виде словаря

    start_state - начальное состояние

    accept_states - допускающие состояния

2. Функция minimize_dfa_table

Реализует алгоритм минимизации через таблицу различий. Ключевая часть - вычисление сигнатур:
python

signature = []
for symbol in sorted(dfa.alphabet):
    next_state = dfa.transitions[state].get(symbol, state)
    # Находим индекс группы, содержащей next_state
    for i, p in enumerate(partition):
        if next_state in p:
            signature.append(i)
            break

3. Функция are_equivalent

Использует BFS для поиска различий:
python

while queue:
    (state1, state2), path = queue.popleft()

    # Проверяем, есть ли различие в допускании
    is_accept1 = state1 in dfa1.accept_states
    is_accept2 = state2 in dfa2.accept_states

    if is_accept1 != is_accept2:
        return False, f"Различаются на строке '{path}'"

Пример работы программы

Входной ДКА:
text

Состояния: q0, q1, q2, q3
Алфавит: a, b
Начальное: q0
Допускающие: q3
Переходы:
  q0 --a--> q1
  q0 --b--> q2
  q1 --a--> q2
  q1 --b--> q3
  q2 --a--> q2
  q2 --b--> q2
  q3 --a--> q3
  q3 --b--> q3

Минимизация:

    Начальное разбиение: [{q3}, {q0, q1, q2}]

    Разбиваем {q0, q1, q2}:

        q0: по a→q1(класс1), по b→q2(класс1)

        q1: по a→q2(класс1), по b→q3(класс0)

        q2: по a→q2(класс1), по b→q2(класс1)
        Результат: [{q3}, {q0, q2}, {q1}]

    Минимизированный ДКА имеет 3 состояния

Проверка эквивалентности:

    Оба автомата принимают строки, содержащие "bb"

    Оба отвергают строки без "bb"

    Результат: автоматы эквивалентны

Особенности реализации

    Обработка неполных переходов:
    Если в исходном ДКА нет перехода по некоторому символу, программа добавляет переход в "ловушку" (trap state).

    Два алгоритма минимизации:

        Алгоритм таблицы различий - простой

        Алгоритм Хопкрофта - эффективный

    Многоуровневая проверка эквивалентности:

        Проверка на тестовых строках

        Систематическая проверка через BFS

        Ручная проверка пользователем

    Работа с CSV:

        Гибкий формат файлов

        Поддержка различных обозначений допускающих состояний

        Сохранение результатов

