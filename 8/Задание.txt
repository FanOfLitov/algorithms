Создание программы на языке высокого уровня,
демонстрирующей дерево разбора для заданной цепочки и описания КС-языка.
Дерево разбора должно иметь легко интерпретируемый пользователем вид и
иметь возможность сохранения в формате CSV.



Берёт описание КС‑грамматики и входную строку.
- Парсит строку по грамматике (определяет, принадлежит ли строка языку и каковы правила вывода).
- Восстанавливает дерево разбора (parse tree) — структурное представление вывода.   #   Рекурсивный нисходящий разбор
- Представляет дерево в удобочитаемом виде (отступы, скобки, граф) и сохраняет узлы дерева в CSV (строка на узел).

1. Ввод
- Загружаем грамматику (список правил типа A -> α) и входную строку w.

2. Парсинг (определяем, разбирается ли строка и собираем информацию)
3. Сбор бэктрейсов
- Во время заполнения таблиц/наборов сохраняем, откуда именно появился каждый нетерминал (правило и разбиение).
- Эти ссылки необходимы для восстановления фактического дерева (а не только для проверки принадлежности).

4. Восстановление дерева (рекурсивно)
- Начинаем от корня (стартовый нетерминал S, покрывающий span [0,n]).
- Рекурсивно: для узла (A, span i..j) смотрим на бэктрейс — правило A -> X Y и точку разбиения k.
 Создаём дочерние узлы для X:(i..k) и Y:(k..j) и т.д.
- Для терминальных правил A -> a создаём лист с токеном a и span длины 1.

5. Представление дерева для пользователя
  - Пример:
    S
      A
        a
      B
        b
- График для красивой визуализации.
- Табличный/строчный вид для CSV: каждый узел — отдельная строка с parent_id, символом, span, глубиной.

6. Экспорт в CSV
- Для каждого узла формируем строку:
  - node_id, parent_id, symbol, token(if terminal), span_start, span_end, depth, children_count
